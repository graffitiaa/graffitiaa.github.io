<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>成员介绍 :)</title>
    <link href="/2022/11/29/homework/"/>
    <url>/2022/11/29/homework/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center">班级</th><th align="center">学号</th><th align="center">姓名</th></tr></thead><tbody><tr><td align="center">2022211314</td><td align="center">2022211415</td><td align="center">刘佳婕</td></tr><tr><td align="center">2022211314</td><td align="center">2022211416</td><td align="center">冯雪莹</td></tr><tr><td align="center">2022211314</td><td align="center">2022211417</td><td align="center">李佳玉</td></tr><tr><td align="center">2022211314</td><td align="center">2022211418</td><td align="center">陈露</td></tr></tbody></table>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些经典的排序与查找(C)</title>
    <link href="/2022/11/26/sortNsearch/"/>
    <url>/2022/11/26/sortNsearch/</url>
    
    <content type="html"><![CDATA[<p><strong>介绍一些经典的数组排序与查找算法</strong>  </p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>除以下外还有桶排序等经典排序算法，此处不做介绍。<br><em>排序以升序为例</em>  </p><h2 id="冒泡排序bubbleSort"><a href="#冒泡排序bubbleSort" class="headerlink" title="冒泡排序bubbleSort"></a>冒泡排序bubbleSort</h2><pre><code class="hljs">void bubbleSort(int a[],int n)&#123;    int pass,i,temp;    for(pass=1;pass&lt;n;pass++)        for(i=0;i&lt;(n-pass);i++)            if(a[i]&gt;a[i+1])            &#123;                temp=a[i];                a[i]=a[i+1];                a[i+1]=temp;            &#125;&#125;</code></pre><h2 id="选择排序selectSort"><a href="#选择排序selectSort" class="headerlink" title="选择排序selectSort"></a>选择排序selectSort</h2><pre><code class="hljs">void selectSortUp(int a[],int n)&#123;    int i,j,temp,min;    for(i=0;i&lt;(n-1);i++)    &#123;        min=findMin(a,i,n-1);        temp=a[min];        a[min]=a[i];        a[i]=temp;    &#125;&#125;int findMin(int a[], int startLoc, int endLoc)&#123;    int i,min=startLoc;    for(i=startLoc+1;i&lt;=endLoc;i++)        if(a[i]&lt;a[min])            min=i;    return min;&#125;</code></pre><h2 id="插入排序insertSort"><a href="#插入排序insertSort" class="headerlink" title="插入排序insertSort"></a>插入排序insertSort</h2><pre><code class="hljs">void insertSort(int a[],int size)&#123;    int i;    for(i=1;i&lt;size;i++)        insertElement(a,i+1,a[i]);&#125;void insertElement(int a[],int size,int num)&#123;    int i,j;    for(i=0;(a[i]&gt;num&amp;&amp;i&lt;size);i++);    for(j=size-2;j&gt;=i;j--)        a[j+1]=a[j];    a[i]=num;&#125;</code></pre><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>除以下外还有分块查找等经典查找算法，此处不做介绍。  </p><h2 id="线性查找linearSearch"><a href="#线性查找linearSearch" class="headerlink" title="线性查找linearSearch"></a>线性查找linearSearch</h2><pre><code class="hljs">int linearSearch(int a[],int key,int size)&#123;    int i;    for(i=0;i&lt;size;i++)        if(a[i]==key)            return i;    return -1;&#125;</code></pre><p>或<br>    int findElement(int a[],int startLoc,int endLoc,int element)<br>    {<br>        int i;<br>        for(i&#x3D;startLoc;i&lt;&#x3D;endLoc&amp;&amp;a[i]!&#x3D;element;i++);<br>        if(i&lt;&#x3D;endLoc)<br>            return i;<br>        else<br>            return -1;<br>    }</p><h2 id="折半查找binarySearch"><a href="#折半查找binarySearch" class="headerlink" title="折半查找binarySearch"></a>折半查找binarySearch</h2><h3 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h3><pre><code class="hljs">int binarySearch(int a[],int key,int left,int right)&#123;    int mid=(left+right)/2;    while(left&lt;=right&amp;&amp;a[mid]!=key)    &#123;        if(key&lt;a[mid])            right=mid-1;        else            left=mid+1;        mid=(left+right)/2;    &#125;    if(left&gt;right)        return -1;    else        return mid;&#125;</code></pre><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><pre><code class="hljs">int recurBinarySearch( int a[],int key,int left,int right)&#123;    int mid=(left+right)/2;    if(left&gt;right)        return -1;    else    &#123;        if(key==a[mid])            return mid;        if(key&lt;a[mid])             return RecurBinarySearch(a,key,left,mid-1);        if(key&gt;a[mid])            return RecurBinarySearch(a,key,mid+1,right);    &#125;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
